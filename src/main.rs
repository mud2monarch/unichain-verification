use alloy::{
    eips::eip1898::BlockNumberOrTag,
    primitives::{aliases, B256},
    providers::{Provider, ProviderBuilder},
    rpc::types::{Block, TransactionReceipt},
};
use clap::Parser;
use dotenv::dotenv;
use op_alloy_network::Optimism;
use std::{env, str::FromStr};
use tracing::{error, info, warn};
use tracing_subscriber;

#[derive(Parser)]
struct Args {
    /// User passes in a transaction hash.
    /// This transaction hash is trusted because it's generated by the user's wallet using the user's own private key.
    #[clap(short, long)]
    transaction_hash: Option<String>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::fmt::init();
    dotenv().ok();

    let rpc_url = &env::var("UNICHAIN_RPC").unwrap();
    info!(
        "Parsed RPC URL. Using: {}...",
        &rpc_url[..rpc_url.len().min(60)]
    );

    // Workaround for a bug; provided at https://t.me/ethers_rs/44751
    let op_provider = ProviderBuilder::new()
        .disable_recommended_fillers()
        .fetch_chain_id()
        .with_gas_estimation()
        .with_cached_nonce_management()
        .network::<Optimism>()
        .connect(rpc_url)
        .await?;

    let args = Args::parse();

    let transaction_hash: B256 = match args.transaction_hash {
        Some(hash) => B256::from_str(&hash).expect("Failed to parse transaction hash argument into bytes 256. Please double check the format."),
        None => {
            warn!("No transaction hash provided. Using default value instead.");
            info!("Default transaction hash: 0x1ae319ba1a236dffe07bcaa323948c9268225f4050ab7eaf86ab5930a937f162");
            B256::from_str("0x1ae319ba1a236dffe07bcaa323948c9268225f4050ab7eaf86ab5930a937f162").unwrap()
        }
    };

    let untrusted_transaction_receipt = op_provider
        .get_transaction_by_hash(transaction_hash)
        .await
        .expect("Failed to get transaction receipt in RPC call.")
        .expect(&format!("Transaction receipt is None for transaction hash {}. Can't continue without a valid transaction.", transaction_hash));

    info!("untrusted tx receipt is {:?}", untrusted_transaction_receipt);

    let untrusted_block_number: BlockNumberOrTag =
        BlockNumberOrTag::Number(
            untrusted_transaction_receipt
            .block_number
            .expect("No block number within transaction receipt.")
        ); // Unichain block number

    let untrusted_block = op_provider
        .get_block_by_number(untrusted_block_number)
        .full()
        .await
        .expect("Failed to get block by number during RPC call with error.") // unwrapping a Result<Option<Block>>.
        .expect(&format!("Block is None for block number {}. Can't continue without a valid block.", untrusted_block_number));

    info!("untrusted block is {:?}", untrusted_block);

    let untrusted_transaction_root: B256 = untrusted_block.header.inner.transactions_root;
    info!("untrusted transaction root is {:?}", untrusted_transaction_root);

    Ok(())   
}
