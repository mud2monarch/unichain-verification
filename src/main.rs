use alloy::{
    eips::eip1898::BlockNumberOrTag,
    primitives::B256,
    providers::{Provider, ProviderBuilder},
    rpc::types::{Block, TransactionReceipt},
};
use clap::Parser;
use dotenv::dotenv;
use op_alloy_network::Optimism;
use std::env;
use tracing::{error, info, warn};
use tracing_subscriber;

#[derive(Parser)]
struct Args {
    /// User passes in a transaction hash.
    /// This transaction hash is trusted because it's generated by the user's wallet using the user's own private key.
    #[clap(short, long)]
    transaction_hash: Option<&str>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::fmt::init();
    dotenv().ok();

    let rpc_url = &env::var("UNICHAIN_RPC").unwrap();
    info!(
        "Parsed RPC URL. Using: {}...",
        &rpc_url[..rpc_url.len().min(60)]
    );

    // Workaround for a bug; provided at https://t.me/ethers_rs/44751
    let op_provider = ProviderBuilder::new()
        .disable_recommended_fillers()
        .fetch_chain_id()
        .with_gas_estimation()
        .with_cached_nonce_management()
        .network::<Optimism>()
        .connect(rpc_url)
        .await?;

    let args = Args::parse();

    let transaction_hash: B256 = B256::from_str(args.transaction_hash).unwrap_or_else(||{
        warn!("No transaction hash provided. Using default value instead.");
        info!("Default transaction hash: 0x1ae319ba1a236dffe07bcaa323948c9268225f4050ab7eaf86ab5930a937f162");
        B256::from_str("0x1ae319ba1a236dffe07bcaa323948c9268225f4050ab7eaf86ab5930a937f162").unwrap()
    });

    // let transaction_hash: B256 =
    //     B256::from_str("0x1ae319ba1a236dffe07bcaa323948c9268225f4050ab7eaf86ab5930a937f162")
    //         .unwrap();
    let untrusted_transaction_receipt = op_provider
        .get_transaction_by_hash(transaction_hash)
        .await
        .expect("Failed to get transaction receipt.");
    info!(
        "untrusted tx receipt is {:?}",
        untrusted_transaction_receipt
    );

    let untrusted_block_number: u64 = receipt
        .block_number
        .expect("Failed to get block number from transaction receipt.");

    let request = client.request(
        "eth_getBlockByNumber",
        (format!("0x{:x}", untrusted_block_number), true),
    );
    let raw_response: serde_json::Value = request
        .await
        .expect("Failed to get block by number during RPC call with error.");

    Ok(())
    // apparently alloy needs us to pass `true` to get all transactions and calculate the transaction root
    // let request = client.request("eth_getBlockByNumber", (format!("0x{:x}", untrusted_block_number), true));
    // let untrusted_block: Block = request.await.expect("Failed to get block by number during RPC call with error.");
    // info!("Block object: {:?}", untrusted_block);

    // info!("Transaction root: {:?}", untrusted_block.header.inner.transactions_root);

    // TODO: calcualte the transaction root, I guess I can't get the root from the RPC call..
    // let untrusted_transaction_root: String = untrusted_block

    // let request = client.request("eth_getBlockByNumber", (untrusted_block_number, true));
    // let untrusted_block = request.await.unwrap();
}
